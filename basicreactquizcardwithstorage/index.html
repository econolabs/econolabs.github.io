<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <link rel="stylesheet" href="../dist/original.css" />

  <script src="../dist/katex.min.js"></script>
  <link rel="stylesheet" href="../dist/katex.min.css" />

  <script src="../dist/jsxgraphcore.js"></script>
  <link rel="stylesheet" type="text/css" href="../dist/jsxgraph.css" />

  <script src="https://cdn.jsdelivr.net/npm/hot-formula-parser@4.0.0/dist/formula-parser.min.js"></script>
  <style>
    .avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      filter: grayscale(100%);
      object-fit: cover;
    }

    .avatarList {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      object-fit: cover;
    }
  </style>

  <title>Basic react Quizcardwithstorage</title>
</head>

<body data-api="AIzaSyDUamZR2aXuP2rFG1AFpb1Ni8aZA5uhSj4" data-base="fincalculations"
  data-app="1:892270777573:web:bdc13e9b47334b4319700c">
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <a target="_blank" class="navbar-brand" href="/">Econolabs</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item">
          <a class="nav-link" href="#"><span class="sr-only"></span></a>
        </li>
      </ul>
      <form class="form-inline my-2 my-lg-0">
        <a href="https://vk.com/dmglvn">
          <img loading="lazy" src="https://sun9-37.userapi.com/c317630/v317630439/76a0/Bz6QTfBog0I.jpg?ava=1" alt=""
            style="
                width: 40px;
                height: 40px;
                border-radius: 50%;
                filter: grayscale(100%);
                object-fit: cover;
              " />
        </a>
      </form>
    </div>
  </nav>

  <div class="container" id="root"></div>

  <script src="../dist/babel.standalone7.27.6.min.js"></script>

  <script src="../dist/basicfirebasecrudauthservices.js"></script>
  <script src="../dist/react18.3.1.production.min.js"></script>
  <script src="../dist/react-dom18.3.1.production.min.js"></script>
  <script src="../dist/react-bootstrap1.6.8.min.js"></script>

  <script type="text/babel">
    let { createRoot } = ReactDOM;
    let {
      useReducer,
      useState,
      createContext,
      useContext,
      useEffect,
      useRef,
    } = React;
    let { Form, Row, Col, Container, Button, Modal, Card } = ReactBootstrap;
    let { getFirebaseNode } = basicfirebasecrudauthservices;

    const ApplicationContext = createContext(null);
    const ApplicationDispatchContext = createContext(null);
    const ProjectContext = createContext(null);
    const ProjectDispatchContext = createContext(null);

    const FormContext = createContext();
    const useFormState = () => useContext(FormContext);

    // function SelectDate({ setDate }) {
    //   async function handleChange(e) {
    //     let { name, value } = e.target;

    //     console.log(name, value);
    //     let d = new Date(e.target.value);

    //     let currentDay = new Intl.DateTimeFormat("en", {
    //       weekday: "short",
    //       year: "numeric",
    //       month: "short",
    //       day: "numeric",
    //     })
    //       .format(new Date(d.getFullYear(), d.getMonth(), d.getDate()))
    //       .replace(/[^a-zA-Z0-9]/g, "_");
    //     setDate(currentDay);
    //   }

    //   return (
    //     <Container>
    //       <Form>
    //         <Row>
    //           <Col>
    //             <Form.Group controlId="formStatePeriod">
    //               <Form.Label>–ü–µ—Ä–∏–æ–¥</Form.Label>
    //               <Form.Control
    //                 type="date"
    //                 name="selecteddate"
    //                 required
    //                 onChange={handleChange}
    //               />
    //             </Form.Group>
    //           </Col>
    //         </Row>
    //       </Form>
    //     </Container>
    //   );
    // }

    // function ExampleModal() {
    //   // State to control whether the modal is shown or hidden
    //   const [show, setShow] = useState(false);

    //   // Handlers to update the state
    //   const handleClose = () => setShow(false);
    //   const handleShow = () => setShow(true);

    //   return (
    //     <>
    //       {/* Button to launch the modal */}
    //       <Button variant="primary" onClick={handleShow}>
    //         Launch demo modal
    //       </Button>

    //       {/* The Modal component, controlled by the 'show' state */}
    //       <Modal show={show} onHide={handleClose}>
    //         <Modal.Header closeButton>
    //           <Modal.Title>Modal heading</Modal.Title>
    //         </Modal.Header>
    //         <Modal.Body>Woohoo, you are reading this text in a modal!</Modal.Body>
    //         <Modal.Footer>
    //           <Button variant="secondary" onClick={handleClose}>
    //             Close
    //           </Button>
    //           <Button variant="primary" onClick={handleClose}>
    //             Save Changes
    //           </Button>
    //         </Modal.Footer>
    //       </Modal>
    //     </>
    //   );
    // }

    // function ShowUsers({ usersAvatars }) {

    //   console.log(usersAvatars);

    //   function openUserInModal() {
    //     dispatch({
    //       type: "SEED_STATE",
    //       payload: {
    //         object: {
    //           isLoading: false,
    //           updatedopenavatars,
    //           uniqueUserEmails,
    //         },
    //       },
    //     });
    //   }
    //   return <Container>{Object.keys(usersAvatars).map(userEmail => {
    //     return <Row>
    //       <Col>
    //         <img src={!!usersAvatars[userEmail]?.avatarUrl ?
    //           usersAvatars[userEmail]?.avatarUrl : "../freelancer.jpg"}
    //           alt=""
    //           className="avatarList"

    //         />
    //       </Col>
    //       <Col>{userEmail}</Col>
    //       <Col><Button size="sm">Change</Button></Col>

    //     </Row>
    //   })}
    //   </Container>;
    // }

    // let initialState = {
    //   email: null,
    //   user: null,
    //   avatarUrl: "",
    //   userEmail: "",
    //   posts: [],
    //   showModal: false,
    //   modal: {},
    //   isLoading: true,

    // }

    // let projectInitialState = {
    //   updatedopenavatars: {},
    //   uniqueUserEmails: [],
    //   showModal: false,
    //   modal: {}
    // }

    // function App() {
    //   const [state, applicationDispatch] = useReducer(
    //     caseReducer,
    //     initialState
    //   );

    //   const [projectState, projectDispatch] = useReducer(
    //     caseReducer,
    //     projectInitialState
    //   );

    //   async function setDate(currentDay) {
    //     console.log(currentDay);
    //     let res = await getFirebaseNode({
    //       url: "/currentDay/" + currentDay + "/posts",
    //       type: "array",
    //     });
    //     let uniqueUserEmails = [
    //       ...new Set(
    //         res.map((item) => item?.email.replace(/[^a-zA-Z0-9]/g, "_"))
    //       ),
    //     ];
    //     console.log(uniqueUserEmails);

    //     let updatedopenavatars = {};

    //     await Promise.all(
    //       uniqueUserEmails.map((userEmail) => {
    //         return getFirebaseNode({
    //           url: "openavatars/" + userEmail,
    //           type: "object",
    //         });
    //       })
    //     ).then((values) => {
    //       values.forEach(
    //         (result, index) =>
    //           (updatedopenavatars[uniqueUserEmails[index]] = result)
    //       );
    //       console.log(updatedopenavatars);
    //     });

    //     projectDispatch({
    //       type: "SEED_STATE",
    //       payload: {
    //         object: {
    //           isLoading: false,
    //           updatedopenavatars,
    //           uniqueUserEmails,
    //         },
    //       },
    //     });
    //     //  console.log(basicfirebasecrudauthservices.loadState())
    //   }

    //   console.log(state);

    //   return (
    //     <ApplicationContext.Provider value={state}>
    //       <ApplicationDispatchContext.Provider value={applicationDispatch}>
    //         <ProjectContext.Provider value={projectState}>
    //           <ProjectDispatchContext.Provider value={projectDispatch}>
    //             <Container>
    //               <SelectDate setDate={setDate} />
    //               <ShowUsers usersAvatars={projectState?.updatedopenavatars} />
    //               <ExampleModal />
    //             </Container>
    //           </ProjectDispatchContext.Provider>
    //         </ProjectContext.Provider>
    //       </ApplicationDispatchContext.Provider>
    //     </ApplicationContext.Provider>

    //   );
    // }



    const caseReducer = basicfirebasecrudauthservices.produce(
      (draft, action) => {
        switch (action.type) {
          case "CALCULATE_SPREADSHEET":
            let newProtoData = {
              ...draft.protoData,
              [action.payload.key]: action.payload.value,
            };
            draft.data = basicfirebasecrudauthservices.createProtoObject(
              basicfirebasecrudauthservices.createNewDraft(
                basicfirebasecrudauthservices.createProtoArray(newProtoData, 10, 1),
              ),
            );
            draft.protoData = {
              ...draft.protoData,
              [action.payload.key]: action.payload.value,
            };
            draft.rerender = Math.random();
            break;

          case "SEED_STATE":
            Object.keys(action.payload.object).map((key) => {
              draft[key] = action.payload.object[key];
            });
            break;

          default:
            break;
        }
      },
    );

    const useDebounce = (value, delay) => {
      const [debouncedValue, setDebouncedValue] = useState(value);

      useEffect(() => {
        const handler = setTimeout(() => {
          setDebouncedValue(value);
        }, delay);
        return () => {
          clearTimeout(handler);
        };
      }, [value, delay]);
      return debouncedValue;
    };

    const DebouncedInput = ({ id, delay = 500, ...props }) => {
      const { state, dispatch } = useFormState();
      const [inputValue, setInputValue] = useState("");
      const debouncedValue = useDebounce(inputValue, delay);

      useEffect(() => {
        dispatch({
          type: "CALCULATE_SPREADSHEET",
          payload: {
            key: id,
            value: debouncedValue,
          },
        });
      }, [debouncedValue, id, dispatch]);

      const handleInputChange = (event) => {
        setInputValue(event.target.value);
      };

      return (
        <Form.Control
          type="text"
          name={id}
          value={inputValue} // The displayed value updates immediately
          onChange={handleInputChange} // The internal state updates immediately
          {...props}
        />
      );
    };

    let casewithcalculations = [
      { id: "A1", orderby: 0, label: "–ù–∞–ª–æ–≥ –Ω–∞ –ø—Ä–∏–±—ã–ª—å" },
      { id: "A2", orderby: 1, label: "–ü—Ä–∏–±—ã–ª—å" },
      { id: "A3", orderby: 2, label: "–†–∞—Å—Ö–æ–¥—ã" },
      { id: "A4", orderby: 3, label: "–î–æ—Ö–æ–¥—ã" },
    ];

    let initialState = {};

    const FormProvider = ({ children }) => {
      const [state, dispatch] = useReducer(caseReducer, initialState);
      return (
        <FormContext.Provider value={{ state, dispatch }}>
          {children}
        </FormContext.Provider>
      );
    };

    const FormDebugger = () => {
      const { state } = useFormState();

      return (
        <Container className="mt-4 p-3 bg-light border rounded">
          <pre className="mb-0">
            <code>{JSON.stringify(state, null, 2)}</code>
          </pre>
        </Container>
      );
    };

    function ActiveCells() {
      const { state } = useFormState();

      return (
        <Container className="mt-5">
          {casewithcalculations.map((item) => {
            let value =
              !!state?.data &&
                state.data.hasOwnProperty(item.id) &&
                typeof state.data[item.id] === "number"
                ? state.data[item.id]
                : null;
            return (
              <Form.Group>
                <Form.Label>
                  {!!value ? item.id + ": " + value : item.id}
                </Form.Label>
                <DebouncedInput id={item.id} placeholder="=2+2" delay={500} />
                <small>{item.label}</small>
              </Form.Group>
            );
          })}
        </Container>
      );
    }

    const KaTeXDisplay = ({
      expression,
      displayMode = true,
      className = "",
    }) => {
      const containerRef = useRef(null);

      useEffect(() => {
        // Ensure that the global 'katex' object is available
        if (window.katex) {
          try {
            window.katex.render(expression, containerRef.current, {
              throwOnError: true,
              displayMode: displayMode, // Set to false for inline math
            });
          } catch (error) {
            console.error("KaTeX rendering error:", error);
          }
        }
      }, [expression]); // Re-run effect if the expression changes

      if (!!displayMode) {
        return (
          <div
            className="katex-block-wrapper"
            style={{
              overflow: "visible",
              minHeight: "50px",
            }}
          >
            <div className={className} ref={containerRef} />
          </div>
        );
      }

      return <div ref={containerRef} />;
    };

    function processTextWithFormulas(inputText) {
      if (!inputText) return null;

      // –í—Ä–µ–º–µ–Ω–Ω—ã–π div –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ HTML
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = inputText;

      // –†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —É–∑–ª–æ–≤
      const processNode = (node, keyPrefix = "") => {
        // –ï—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —É–∑–µ–ª
        if (node.nodeType === Node.TEXT_NODE) {
          const text = node.textContent;
          if (!text.trim()) return null;

          // –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Ñ–æ—Ä–º—É–ª—ã –∏ –æ–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
          const parts = text.split(/(\$\$[^$]+\$\$|\$[^$]+\$)/g);
          const result = [];

          parts.forEach((part, index) => {
            if (!part.trim()) return;

            // –ë–ª–æ—á–Ω–∞—è —Ñ–æ—Ä–º—É–ª–∞ $$...$$
            if (
              part.startsWith("$$") &&
              part.endsWith("$$") &&
              part.length > 4
            ) {
              const formula = part.slice(2, -2);
              result.push(
                <KaTeXDisplay
                  key={`${keyPrefix}-block-${index}`}
                  expression={formula}
                />,
              );
            }
            // –ò–Ω–ª–∞–π–Ω —Ñ–æ—Ä–º—É–ª–∞ $...$
            else if (
              part.startsWith("$") &&
              part.endsWith("$") &&
              part.length > 2 &&
              !part.startsWith("$$")
            ) {
              const formula = part.slice(1, -1);
              result.push(
                <KaTeXDisplay
                  key={`${keyPrefix}-inline-${index}`}
                  expression={formula}
                />,
              );
            }
            // –û–±—ã—á–Ω—ã–π —Ç–µ–∫—Å—Ç
            else {
              result.push(
                <span key={`${keyPrefix}-text-${index}`}>{part}</span>,
              );
            }
          });

          return result.length > 1 ? result : result[0];
        }

        // –ï—Å–ª–∏ —ç—Ç–æ —ç–ª–µ–º–µ–Ω—Ç
        if (node.nodeType === Node.ELEMENT_NODE) {
          const tagName = node.tagName.toLowerCase();

          // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º script, style, svg
          if (
            tagName === "script" ||
            tagName === "style" ||
            tagName === "svg"
          ) {
            return null;
          }

          // –°–æ–∑–¥–∞—ë–º props –¥–ª—è React —ç–ª–µ–º–µ–Ω—Ç–∞
          const props = {
            key: `${keyPrefix}-${tagName}-${Math.random().toString(36).substr(2, 9)}`,
            className: node.className || "",
            style: node.style.cssText ? { cssText: node.style.cssText } : {},
          };

          // –ö–æ–ø–∏—Ä—É–µ–º –∞—Ç—Ä–∏–±—É—Ç—ã (–∫—Ä–æ–º–µ class –∏ style)
          Array.from(node.attributes).forEach((attr) => {
            if (attr.name !== "class" && attr.name !== "style") {
              props[attr.name] = attr.value;
            }
          });

          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–æ—á–µ—Ä–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
          const children = [];
          node.childNodes.forEach((child, index) => {
            const processedChild = processNode(
              child,
              `${keyPrefix}-child-${index}`,
            );
            if (processedChild) {
              if (Array.isArray(processedChild)) {
                children.push(...processedChild);
              } else {
                children.push(processedChild);
              }
            }
          });

          // –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ç–µ–≥–æ–≤
          switch (tagName) {
            case "div":
            case "span":
            case "p":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
            case "ul":
            case "ol":
            case "li":
            case "strong":
            case "em":
            case "a":
              return React.createElement(tagName, props, children);

            case "br":
              return React.createElement("br", { key: props.key });

            case "hr":
              return React.createElement("hr", { key: props.key });

            case "img":
              return React.createElement("img", {
                key: props.key,
                src: node.src,
                alt: node.alt || "",
                className: props.className,
                style: props.style,
              });

            default:
              // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ç–µ–≥–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º dangerouslySetInnerHTML
              return (
                <div
                  key={props.key}
                  dangerouslySetInnerHTML={{ __html: node.outerHTML }}
                />
              );
          }
        }

        return null;
      };

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤—Å–µ –¥–æ—á–µ—Ä–Ω–∏–µ —É–∑–ª—ã tempDiv
      const result = [];
      tempDiv.childNodes.forEach((child, index) => {
        const processed = processNode(child, `root-${index}`);
        if (processed) {
          if (Array.isArray(processed)) {
            result.push(...processed);
          } else {
            result.push(processed);
          }
        }
      });

      return result;
    }

    const ProcessKatex = ({ text, className = "" }) => {
      return <div className={className}>{processTextWithFormulas(text)}</div>;
    };

    function QuizWithRandomNumber() {
      return <div>QuizWithRandomNumber</div>;
    }

    function SingleQuizCardWithStorage({
      key = Math.random(),
      header = "header",
      imageurl = "https://i0.wp.com/digital-photography-school.com/wp-content/uploads/2019/05/sasha-stories-259551-unsplash-e1558728808681.jpg?resize=1500%2C1125&ssl=1",
      title = "title",
    }) {
      return (
        <Card bg={"light"} style={{ width: "95%", margin: "1rem" }} key={key}>
          <Card.Header>{header}</Card.Header>
          <Card.Body>
            {!!imageurl ? <Card.Img variant="top" src={imageurl} /> : null}
            <Card.Title>{title}</Card.Title>

            <Card.Text>Ha Ha</Card.Text>

            <KaTeXDisplay expression={"\\sin 0^{\\circ}"} />

            <ProcessKatex
              text={`<div class="container-fluid p-0">
        <div class="alert alert-info mb-3" role="alert">
          <h5 class="alert-heading">üìê –°–∏–Ω—É—Å —É–≥–ª–∞ 0¬∞</h5>
          <p>–°–∏–Ω—É—Å —É–≥–ª–∞ - —ç—Ç–æ –æ—Ä–¥–∏–Ω–∞—Ç–∞ (y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞) —Ç–æ—á–∫–∏ –Ω–∞ –µ–¥–∏–Ω–∏—á–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏.</p>
        </div>

        <div class="row">
          <div class="col-md-6">
            <div class="card border-primary mb-3">
              <div class="card-header bg-primary text-white">
                <strong>–ì–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ</strong>
              </div>
              <div class="card-body">
                <p>–ù–∞ –µ–¥–∏–Ω–∏—á–Ω–æ–π –æ–∫—Ä—É–∂–Ω–æ—Å—Ç–∏ —É–≥–æ–ª 0¬∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ç–æ—á–∫–µ (1, 0).</p>
                <p>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: $x = 1$, $y = 0$</p>
                <p>$$\\sin 0^{\\circ} = y = 0$$</p>
              </div>
            </div>
          </div>

          <div class="col-md-6">
            <div class="card border-success mb-3">
              <div class="card-header bg-success text-white">
                <strong>–ü–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é</strong>
              </div>
              <div class="card-body">
                <p>–í –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–æ–º —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–µ:</p>
                <p>$$\\sin \\alpha = \\frac{\\text{–ø—Ä–æ—Ç–∏–≤–æ–ª–µ–∂–∞—â–∏–π –∫–∞—Ç–µ—Ç}}{\\text{–≥–∏–ø–æ—Ç–µ–Ω—É–∑–∞}}$$</p>
                <p>–ü—Ä–∏ —É–≥–ª–µ 0¬∞ –ø—Ä–æ—Ç–∏–≤–æ–ª–µ–∂–∞—â–∏–π –∫–∞—Ç–µ—Ç —Ä–∞–≤–µ–Ω 0, –ø–æ—ç—Ç–æ–º—É:</p>
                <p>$$\\sin 0^{\\circ} = \\frac{0}{\\text{–≥–∏–ø–æ—Ç–µ–Ω—É–∑–∞}} = 0$$</p>
              </div>
            </div>
          </div>
        </div>

        <div class="alert alert-light border">
          <h6>üí° –ó–∞–ø–æ–º–Ω–∏—Ç–µ:</h6>
          <p class="mb-1">$$\\sin 0^{\\circ} = 0$$</p>
          <p class="mb-0">–ù—É–ª–µ–≤–æ–π —É–≥–æ–ª - –Ω—É–ª–µ–≤–æ–π —Å–∏–Ω—É—Å</p>
        </div>
      </div>`}
            />
          </Card.Body>
        </Card>
      );
    }

    const UnitVectors = () => {
      const boardRef = useRef(null);

      useEffect(() => {
        const board = JXG.JSXGraph.initBoard(boardRef.current, {
          boundingbox: [-1.5, 1.5, 1.5, -1.5],
          axis: true,
          grid: true,
          showNavigation: false,
          showCopyright: false,
        });

        const O = board.create("point", [0, 0], {
          name: "O",
          size: 4,
          color: "#212529",
          fixed: true,
        });

        const colors = {
          i: "#dc3545",
          j: "#007bff",
          negi: "#ffc107",
          negj: "#28a745",
          gray: "#6c757d",
        };

        // –í–µ–∫—Ç–æ—Ä—ã —Å —è–≤–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ –¥–ª—è –ª–µ–π–±–ª–æ–≤
        const vectors = [
          {
            end: [1, 0],
            tex: "\\Huge { \\vec{ i }}",
            color: colors.i,
            labelX: 1.2,
            labelY: 0.2,
          },
          {
            end: [0, 1],
            tex: "\\Huge { \\vec{ j }}",
            color: colors.j,
            labelX: 0.1,
            labelY: 1.2,
          },
          {
            end: [-1, 0],
            tex: "-\\Huge { \\vec{ i }}",
            color: colors.negi,
            labelX: -1.2,
            labelY: 0.2,
          },
          {
            end: [0, -1],
            tex: "-\\Huge { \\vec{ j }}",
            color: colors.negj,
            labelX: 0.1,
            labelY: -1.2,
          },
        ];

        vectors.forEach((vec) => {
          // console.log(vec);

          const P = board.create("point", vec.end, {
            size: 3,
            color: vec.color,
            fixed: true,
          });

          board.create("arrow", [O, P], {
            strokeColor: vec.color,
            strokeWidth: 3,
            lastArrow: true,
            size: 8,
          });

          //  var t1 = board.create('text',[0,1,"Hello World"]);
          // const text =  board.create('text', [5, 10], 'My Text');

          // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç —Å KaTeX
          //  –í–∞–∂–Ω–æ: –ø–µ—Ä–µ–¥–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞–∫ –º–∞—Å—Å–∏–≤
          const text = board.create("text", [vec.labelX, vec.labelY, "..."], {
            color: vec.color,
            fixed: true,
            parse: false, // –û—Ç–∫–ª—é—á–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ JSXGraph
          });

          // –†–µ–Ω–¥–µ—Ä–∏–º KaTeX –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–∫ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
          try {
            const html = katex.renderToString(vec.tex, {
              displayMode: false,
              throwOnError: false,
            });
            text.setText(html);
          } catch (error) {
            console.error("KaTeX error:", error);
            text.setText(vec.tex);
          }

          board.create("circle", [O, 1], {
            strokeColor: colors.gray,
            strokeWidth: 0.5,
            dash: 2,
          });
        });

        return () => board.unsuspendUpdate();
      }, []);

      return (
        <div>
          <div ref={boardRef} style={{ height: "400px", width: "400px" }} />
        </div>
      );
    };

    const createGraphByType = (board, graphType) => {
      const graphFactories = {
        // 1. –¢—Ä–∏–≥–æ–Ω–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –≥—Ä–∞—Ñ–∏–∫–∏

        // 1. –¢—Ä–∏–≥–æ–Ω–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏–µ –≥—Ä–∞—Ñ–∏–∫–∏
        trigGraphs: () => {
          // –°–∏–Ω—É—Å –∏ –∫–æ—Å–∏–Ω—É—Å
          board.create('functiongraph', [x => Math.sin(x), -Math.PI, Math.PI], {
            strokeColor: 'blue',
            strokeWidth: 2,
            name: 'sin(x)'
          });

          board.create('functiongraph', [x => Math.cos(x), -Math.PI, Math.PI], {
            strokeColor: 'red',
            strokeWidth: 2,
            name: 'cos(x)'
          });

          // –ü–æ–¥–ø–∏—Å–∏
          board.create('text', [1.2, 0.8, 'y = sin(x)'], { color: 'blue' });
          board.create('text', [1.2, 0.6, 'y = cos(x)'], { color: 'red' });
        },
        // 2. –ï–¥–∏–Ω–∏—á–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã


        unitVectors: () => {
          const O = board.create("point", [0, 0], {
            name: "O",
            size: 4,
            color: "#212529",
            fixed: true,
          });

          const colors = {
            i: "#dc3545",
            j: "#007bff",
            negi: "#ffc107",
            negj: "#28a745",
            gray: "#6c757d",
          };

          // –í–µ–∫—Ç–æ—Ä—ã —Å —è–≤–Ω—ã–º–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ –¥–ª—è –ª–µ–π–±–ª–æ–≤
          const vectors = [
            {
              end: [1, 0],
              tex: "\\Huge { \\vec{ i }}",
              color: colors.i,
              labelX: 1.2,
              labelY: 0.2,
            },
            {
              end: [0, 1],
              tex: "\\Huge { \\vec{ j }}",
              color: colors.j,
              labelX: 0.1,
              labelY: 1.2,
            },
            {
              end: [-1, 0],
              tex: "-\\Huge { \\vec{ i }}",
              color: colors.negi,
              labelX: -1.2,
              labelY: 0.2,
            },
            {
              end: [0, -1],
              tex: "-\\Huge { \\vec{ j }}",
              color: colors.negj,
              labelX: 0.1,
              labelY: -1.2,
            },
          ];

          vectors.forEach((vec) => {
            // console.log(vec);

            const P = board.create("point", vec.end, {
              size: 3,
              color: vec.color,
              fixed: true,
            });

            board.create("arrow", [O, P], {
              strokeColor: vec.color,
              strokeWidth: 3,
              lastArrow: true,
              size: 8,
            });

            //  var t1 = board.create('text',[0,1,"Hello World"]);
            // const text =  board.create('text', [5, 10], 'My Text');

            // –°–æ–∑–¥–∞–µ–º —Ç–µ–∫—Å—Ç —Å KaTeX
            //  –í–∞–∂–Ω–æ: –ø–µ—Ä–µ–¥–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–∞–∫ –º–∞—Å—Å–∏–≤
            const text = board.create(
              "text",
              [vec.labelX, vec.labelY, "..."],
              {
                color: vec.color,
                fixed: true,
                parse: false, // –û—Ç–∫–ª—é—á–∞–µ–º –ø–∞—Ä—Å–∏–Ω–≥ JSXGraph
              },
            );

            // –†–µ–Ω–¥–µ—Ä–∏–º KaTeX –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–∫ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
            try {
              const html = katex.renderToString(vec.tex, {
                displayMode: false,
                throwOnError: false,
              });
              text.setText(html);
            } catch (error) {
              console.error("KaTeX error:", error);
              text.setText(vec.tex);
            }

            board.create("circle", [O, 1], {
              strokeColor: colors.gray,
              strokeWidth: 0.5,
              dash: 2,
            });
          });
        },

        // 3. –ú–µ–¥–∏–∞–Ω–∞ –Ω–∞–±–æ—Ä–∞ —á–∏—Å–µ–ª
        medianVisualization: () => {
          // –î–∞–Ω–Ω—ã–µ: 2, 3, 5, 7, 9
          const data = [2, 3, 5, 7, 9];

          // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ç–æ—á–∫–∏
          data.forEach((value, index) => {
            board.create('point', [index, value], {
              name: value.toString(),
              size: 3,
              fillColor: value === 5 ? 'red' : 'black' // –ú–µ–¥–∏–∞–Ω–∞ –∫—Ä–∞—Å–Ω—ã–º
            });
          });

          // –õ–∏–Ω–∏—è –º–µ–¥–∏–∞–Ω—ã
          board.create('line', [[2, 0], [2, 10]], {
            strokeColor: 'red',
            strokeWidth: 2,
            dash: 2
          });

          board.create('text', [2.1, 0.5, '–ú–µ–¥–∏–∞–Ω–∞ = 5'], { color: 'red' });
        },

        // 4. –î–∏–∞–≥—Ä–∞–º–º–∞ –≠–π–ª–µ—Ä–∞
        eulerDiagram: () => {
          // –î–≤–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ (–∫—Ä—É–≥–∏)
          const circleA = board.create('circle', [[-1, 0], 2], {
            fillColor: 'rgba(135, 206, 250, 0.3)',
            strokeColor: 'blue',
            strokeWidth: 2
          });

          const circleB = board.create('circle', [[1, 0], 2], {
            fillColor: 'rgba(255, 182, 193, 0.3)',
            strokeColor: 'red',
            strokeWidth: 2
          });

          // –ü–æ–¥–ø–∏—Å–∏
          board.create('text', [-3, 0, '–ú–Ω–æ–∂–µ—Å—Ç–≤–æ A']);
          board.create('text', [3, 0, '–ú–Ω–æ–∂–µ—Å—Ç–≤–æ B']);
          board.create('text', [0, 0, 'A ‚à© B']);
        },

        // 5. –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ü–∞—Å–∫–∞–ª—è
        pascalTriangle: () => {
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 5 —Å—Ç—Ä–æ–∫
          const pascalRows = [
            [1],
            [1, 1],
            [1, 2, 1],
            [1, 3, 3, 1],
            [1, 4, 6, 4, 1]
          ];

          for (let row = 0; row < pascalRows.length; row++) {
            for (let col = 0; col < pascalRows[row].length; col++) {
              const x = col - row / 2;
              const y = 4 - row;

              board.create('point', [x, y], {
                size: 0,
                name: pascalRows[row][col].toString(),
                fontSize: 12
              });
            }
          }

          board.create('text', [0, -0.5, '–¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ –ü–∞—Å–∫–∞–ª—è']);
        },

        // 6. –ù–æ—Ä–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
        normalDistribution: () => {
          // –§—É–Ω–∫—Ü–∏—è –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
          const normalPDF = x => Math.exp(-x * x / 2) / Math.sqrt(2 * Math.PI);

          board.create('functiongraph', [normalPDF, -4, 4], {
            strokeColor: 'blue',
            strokeWidth: 3
          });

          // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è Œº¬±œÉ
          board.create('line', [[-1, 0], [-1, 0.4]], {
            strokeColor: 'red',
            strokeWidth: 1,
            dash: 2
          });
          board.create('line', [[1, 0], [1, 0.4]], {
            strokeColor: 'red',
            strokeWidth: 1,
            dash: 2
          });

          board.create('text', [0, -0.1, '–ù–æ—Ä–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ N(0,1)']);
        },

        // 7. –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
        uniformDistribution: () => {
          // –ü—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –Ω–∞ [0, 1]
          board.create('polygon', [
            [0, 0],
            [0, 1],
            [1, 1],
            [1, 0]
          ], {
            fillColor: 'lightblue',
            borders: { strokeColor: 'blue', strokeWidth: 2 }
          });

          board.create('text', [0.5, -0.1, '–†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ U[0,1]']);
        },

        // 8. –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
        binomialDistribution: () => {
          // –ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è n=10, p=0.5
          const binomialPMF = k => {
            // C(10, k) * 0.5^10
            const combinations = (n, k) => {
              let result = 1;
              for (let i = 1; i <= k; i++) {
                result = result * (n - k + i) / i;
              }
              return result;
            };
            return combinations(10, k) * Math.pow(0.5, 10);
          };

          // –†–∏—Å—É–µ–º —Ç–æ—á–∫–∏
          const points = [];
          for (let k = 0; k <= 10; k++) {
            const point = board.create('point', [k, binomialPMF(k)], {
              size: 3,
              fillColor: 'blue'
            });
            points.push(point);

            // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
            board.create('line', [[k, 0], [k, binomialPMF(k)]], {
              strokeColor: 'lightblue',
              strokeWidth: 1
            });
          }

          board.create('text', [5, -0.05, '–ë–∏–Ω–æ–º–∏–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ B(10, 0.5)']);
        },

        // 9. –ü–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –º–Ω–æ–∂–µ—Å—Ç–≤
        intersectionDiagram: () => {
          // –î–≤–∞ –ø–µ—Ä–µ—Å–µ–∫–∞—é—â–∏—Ö—Å—è –∫—Ä—É–≥–∞
          board.create('circle', [[-0.5, 0], 1.5], {
            fillColor: 'rgba(135, 206, 250, 0.5)',
            strokeColor: 'blue',
            strokeWidth: 2
          });

          board.create('circle', [[0.5, 0], 1.5], {
            fillColor: 'rgba(255, 182, 193, 0.5)',
            strokeColor: 'red',
            strokeWidth: 2
          });

          board.create('text', [-1.5, 0, 'A']);
          board.create('text', [1.5, 0, 'B']);
          board.create('text', [0, 0, 'A ‚à© B']);
        },

        // 10. –°—Ç—Ä–æ–∫–∞ —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ü–∞—Å–∫–∞–ª—è
        pascalRow: () => {
          // 4-—è —Å—Ç—Ä–æ–∫–∞: 1, 4, 6, 4, 1
          const row4 = [1, 4, 6, 4, 1];

          row4.forEach((value, index) => {
            board.create('point', [index, 0], {
              size: 0,
              name: value.toString(),
              fontSize: 16,
              fillColor: 'red'
            });
          });

          board.create('text', [2, -0.5, '–°—Ç—Ä–æ–∫–∞ 4 —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∞ –ü–∞—Å–∫–∞–ª—è: (a+b)‚Å¥']);
        },

        // 11. –°—Ä–µ–¥–Ω–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
        meanVisualization: () => {
          // –î–∞–Ω–Ω—ã–µ: 4, 8, 6, 2, 10
          const data = [4, 8, 6, 2, 10];
          const mean = data.reduce((a, b) => a + b) / data.length; // 6

          // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ç–æ—á–∫–∏ –∏ —Å—Ä–µ–¥–Ω—é—é –ª–∏–Ω–∏—é
          data.forEach((value, index) => {
            board.create('point', [index, value], {
              name: value.toString(),
              size: 3
            });
          });

          // –õ–∏–Ω–∏—è —Å—Ä–µ–¥–Ω–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
          board.create('line', [[-0.5, mean], [4.5, mean]], {
            strokeColor: 'green',
            strokeWidth: 2,
            dash: 2
          });

          board.create('text', [2.5, mean + 0.5, `–°—Ä–µ–¥–Ω–µ–µ = ${mean}`], { color: 'green' });
        },

        // 12. –°–∏–Ω—É—Å–æ–∏–¥–∞ —Å —Ä–∞–∑–Ω—ã–º–∏ –ø–µ—Ä–∏–æ–¥–∞–º–∏
        sineWaves: () => {
          // sin(x)
          board.create('functiongraph', [x => Math.sin(x), -Math.PI, Math.PI], {
            strokeColor: 'blue',
            strokeWidth: 2,
            name: 'sin(x)'
          });

          // sin(2x) - –≤ 2 —Ä–∞–∑–∞ —á–∞—â–µ
          board.create('functiongraph', [x => Math.sin(2 * x), -Math.PI, Math.PI], {
            strokeColor: 'red',
            strokeWidth: 2,
            name: 'sin(2x)'
          });

          // sin(x/2) - –≤ 2 —Ä–∞–∑–∞ —Ä–µ–∂–µ
          board.create('functiongraph', [x => Math.sin(x / 2), -Math.PI, Math.PI], {
            strokeColor: 'green',
            strokeWidth: 2,
            name: 'sin(x/2)'
          });
        },

        // 13. –í–µ–∫—Ç–æ—Ä–Ω–æ–µ —Å–ª–æ–∂–µ–Ω–∏–µ
        vectorAddition: () => {
          const origin = [0, 0];

          // –í–µ–∫—Ç–æ—Ä a
          const a = board.create('arrow', [origin, [2, 1]], {
            strokeColor: 'red',
            strokeWidth: 3,
            name: 'a‚Éó'
          });

          // –í–µ–∫—Ç–æ—Ä b
          const b = board.create('arrow', [[2, 1], [3, 3]], {
            strokeColor: 'blue',
            strokeWidth: 3,
            name: 'b‚Éó'
          });

          // –°—É–º–º–∞ a + b
          const sum = board.create('arrow', [origin, [3, 3]], {
            strokeColor: 'green',
            strokeWidth: 3,
            name: 'a‚Éó + b‚Éó'
          });

          // –ü—Ä–∞–≤–∏–ª–æ –ø–∞—Ä–∞–ª–ª–µ–ª–æ–≥—Ä–∞–º–º–∞
          board.create('arrow', [origin, [1, 2]], {
            strokeColor: 'blue',
            strokeWidth: 3,
            opacity: 0.5,
            dash: 2
          });

          board.create('arrow', [[2, 1], [3, 3]], {
            strokeColor: 'red',
            strokeWidth: 3,
            opacity: 0.5,
            dash: 2
          });
        },

        // 14. –ö—Ä—É–≥–æ–≤–∞—è –¥–∏–∞–≥—Ä–∞–º–º–∞ (pie chart)
        pieChart: () => {
          const data = [30, 25, 20, 15, 10]; // –ü—Ä–æ—Ü–µ–Ω—Ç—ã
          const colors = ['red', 'blue', 'green', 'yellow', 'purple'];
          const labels = ['A', 'B', 'C', 'D', 'E'];

          let startAngle = 0;
          const total = data.reduce((a, b) => a + b, 0);

          data.forEach((value, index) => {
            const angle = (value / total) * 2 * Math.PI;
            const endAngle = startAngle + angle;

            // –°–µ–∫—Ç–æ—Ä –∫—Ä—É–≥–∞
            const sector = board.create('sector', [
              [0, 0], // –¶–µ–Ω—Ç—Ä
              [Math.cos(startAngle), Math.sin(startAngle)], // –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞
              [Math.cos(endAngle), Math.sin(endAngle)] // –ö–æ–Ω–µ—á–Ω–∞—è —Ç–æ—á–∫–∞
            ], {
              fillColor: colors[index],
              strokeColor: 'black',
              strokeWidth: 1
            });

            // –ú–µ—Ç–∫–∞
            const midAngle = startAngle + angle / 2;
            board.create('text', [
              0.7 * Math.cos(midAngle),
              0.7 * Math.sin(midAngle),
              `${labels[index]}: ${value}%`
            ], { fontSize: 10 });

            startAngle = endAngle;
          });
        },

        // 15. –ì–∏—Å—Ç–æ–≥—Ä–∞–º–º–∞
        histogram: () => {
          const data = [3, 7, 4, 9, 2, 5, 8];
          const barWidth = 0.8;

          data.forEach((value, index) => {
            // –°—Ç–æ–ª–±–µ—Ü –≥–∏—Å—Ç–æ–≥—Ä–∞–º–º—ã
            board.create('polygon', [
              [index - barWidth / 2, 0],
              [index - barWidth / 2, value],
              [index + barWidth / 2, value],
              [index + barWidth / 2, 0]
            ], {
              fillColor: index % 2 === 0 ? 'lightblue' : 'lightcoral',
              strokeColor: 'black',
              strokeWidth: 1
            });

            // –ó–Ω–∞—á–µ–Ω–∏–µ —Å–≤–µ—Ä—Ö—É
            board.create('text', [index, value + 0.3, value.toString()], {
              fontSize: 10
            });
          });
        }
      }


        ;
      // –í—ã–±–∏—Ä–∞–µ–º —Ñ–∞–±—Ä–∏–∫—É –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—É—é —Ñ—É–Ω–∫—Ü–∏—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
      return (
        graphFactories[graphType] ||
        (() => {
          console.warn(`–ì—Ä–∞—Ñ–∏–∫ —Ç–∏–ø–∞ "${graphType}" –Ω–µ –Ω–∞–π–¥–µ–Ω`);
        })
      );
    };

    // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç
    const JSXGraphComponent = ({
      graphType = "unitVectors",
      boundingbox = [-5, 5, 5, -5],
      width = 400,
      height = 400,
    }) => {
      const boardRef = useRef(null);

      useEffect(() => {
        if (!boardRef.current) return;

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–æ—Å–∫–∏
        const board = JXG.JSXGraph.initBoard(boardRef.current, {
          boundingbox: boundingbox, // –ë–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
          axis: true,
          grid: true,
          showNavigation: false,
          showCopyright: false,
        });

        // –ü–æ–ª—É—á–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞
        const createGraph = createGraphByType(board, graphType);

        // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫
        createGraph();

        // –û—á–∏—Å—Ç–∫–∞
        return () => {
          if (board) {
            board.destroy();
          }
        };
      }, [graphType]); // –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ç–∏–ø–∞

      return (
        <div style={{ margin: "10px 0" }}>
          <div
            ref={boardRef}
            style={{
              width: `${width}px`,
              height: `${height}px`,
              border: "1px solid #ccc",
              borderRadius: "4px",
            }}
          />
        </div>
      );
    };


    function DevelopQuizWithRandomValue() {
      const [quiz, dispatch] = useReducer(caseReducer, {
        text: "text",
        hint: "hint",
        answer: "answer"
      });

      // Generic change handler for all inputs
      const handleInputChange = (e) => {
        const { name, value } = e.target;
        dispatch({
          type: "SEED_STATE",
          payload: {
            object: {
              [name]: value,            
            },
          },
        });


      };

      let quizresult = basicfirebasecrudauthservices.generateRandomValue(quiz);
      console.log(quizresult)
      return <Container>
           <Form>
             
            <Row>
               <Col>
                 <Form.Group controlId="formStateText">
                   <Form.Label className="text-secondary">text</Form.Label>
                   <Form.Control
                    as="textarea" rows={5}
                    name="text"
                     required
                     onChange={handleInputChange}
                   />
                   <div className="text-small">{quizresult?.text}</div>
                 </Form.Group>
               </Col>
             </Row>

             <hr/>

             <Row>
               <Col>
                 <Form.Group controlId="formStateAnswer">
                   <Form.Label className="text-secondary">answer</Form.Label>
                   <Form.Control
                     type="text"
                     name="answer"
                     required
                     onChange={handleInputChange}
                   />
                   <div className="text-small">{quizresult?.answer}</div>
                 </Form.Group>
               </Col>
             </Row>

             <hr/>

             <Row>
               <Col>
                 <Form.Group controlId="formStateHint">
                   <Form.Label className="text-secondary">hint</Form.Label>
                   <Form.Control
                     as="textarea" rows={5}
                     name="hint"
                     required
                     onChange={handleInputChange}
                   />
                   <div className="text-small">{quizresult?.hint}</div>
                 </Form.Group>
               </Col>
             </Row>

           </Form>
         </Container>
    }

    function App() {
      const [state, dispatch] = useReducer(caseReducer, initialState);

      return (
        <FormProvider>
          <Container className="mt-5">
            <DevelopQuizWithRandomValue />
            <SingleQuizCardWithStorage />
            <ActiveCells />
            <FormDebugger />
            <JSXGraphComponent graphType="normalDistribution"
              boundingbox={[-5, 5, 5, -5]}
            />
          </Container>
        </FormProvider>
      );
    }

    createRoot(root).render(<App />);
  </script>
</body>

</html>